<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mondrian Generator</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      background: #000; 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      min-height: 100vh;
      overflow: hidden;
    }
    canvas { display: block; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <script>
    // ===========================================
    // TWEAKABLE PARAMETERS
    // ===========================================
    
    const CONFIG = {
      // Subdivision behavior
      splitChance: 0.85,        // Probability of splitting a cell (0-1)
      minCellSize: 60,          // Minimum cell dimension before stopping
      splitRatio: [0.1, 0.9],   // Range for where to place the split (0-1)
      minSplits: 2,             // Minimum number of splits
      maxSplits: 4,             // Maximum number of splits
      
      // Line styling
      lineWidth: 6,             // Thickness of black dividing lines
      lineColor: '#000000',
      
      // Colors and their relative weights
      colors: [
        { color: '#FFFFFF', weight: 10 },  // White (most common)
        { color: '#D40920', weight: 2 },   // Red
        { color: '#1356A2', weight: 2 },   // Blue
        { color: '#F7D842', weight: 2 },   // Yellow
      ],
      
      // Canvas padding from edge
      padding: 20,
    };

    // ===========================================
    // UTILITY FUNCTIONS
    // ===========================================
    
    // Random float between min and max
    function random(min, max) {
      return Math.random() * (max - min) + min;
    }
    
    // Pick a color based on weights
    function pickColor() {
      const totalWeight = CONFIG.colors.reduce((sum, c) => sum + c.weight, 0);
      let rand = Math.random() * totalWeight;
      
      for (const c of CONFIG.colors) {
        rand -= c.weight;
        if (rand <= 0) return c.color;
      }
      return CONFIG.colors[0].color;
    }

    // ===========================================
    // SUBDIVISION ALGORITHM
    // ===========================================
    
    // Recursively subdivide a rectangle
    // Returns an array of final rectangles { x, y, w, h }
    function subdivide(x, y, w, h, depth = 0) {
      const canSplitH = w >= CONFIG.minCellSize * 2;
      const canSplitV = h >= CONFIG.minCellSize * 2;
      const shouldSplit = Math.random() < CONFIG.splitChance;
      
      // Base case: can't split or chose not to
      if ((!canSplitH && !canSplitV) || !shouldSplit) {
        return [{ x, y, w, h }];
      }
      
      // Decide split direction
      let splitHorizontal;
      if (canSplitH && canSplitV) {
        splitHorizontal = w > h ? true : h > w ? false : Math.random() < 0.5;
      } else {
        splitHorizontal = canSplitH;
      }
      
      // Determine how many splits (2-4 pieces)
      const dimension = splitHorizontal ? w : h;
      const maxPossibleSplits = Math.floor(dimension / CONFIG.minCellSize);
      const numPieces = Math.min(
        maxPossibleSplits,
        Math.floor(random(CONFIG.minSplits, CONFIG.maxSplits + 1))
      );
      
      if (numPieces < 2) {
        return [{ x, y, w, h }];
      }
      
      // Generate split points
      const [minRatio, maxRatio] = CONFIG.splitRatio;
      const splitPoints = [];
      
      for (let i = 0; i < numPieces - 1; i++) {
        splitPoints.push(random(minRatio, maxRatio));
      }
      splitPoints.sort((a, b) => a - b);
      
      // Ensure minimum spacing between splits
      const minSpacing = CONFIG.minCellSize / dimension;
      let valid = splitPoints[0] >= minSpacing;
      for (let i = 1; i < splitPoints.length && valid; i++) {
        if (splitPoints[i] - splitPoints[i-1] < minSpacing) valid = false;
      }
      if (splitPoints.length > 0 && 1 - splitPoints[splitPoints.length-1] < minSpacing) valid = false;
      
      // Fall back to single split if spacing invalid
      if (!valid) {
        splitPoints.length = 0;
        splitPoints.push(random(minRatio, maxRatio));
      }
      
      // Create child rectangles
      const results = [];
      let prev = 0;
      
      for (const ratio of splitPoints) {
        if (splitHorizontal) {
          const childW = (ratio - prev) * w;
          results.push(...subdivide(x + prev * w, y, childW, h, depth + 1));
        } else {
          const childH = (ratio - prev) * h;
          results.push(...subdivide(x, y + prev * h, w, childH, depth + 1));
        }
        prev = ratio;
      }
      
      // Final piece
      if (splitHorizontal) {
        results.push(...subdivide(x + prev * w, y, (1 - prev) * w, h, depth + 1));
      } else {
        results.push(...subdivide(x, y + prev * h, w, (1 - prev) * h, depth + 1));
      }
      
      return results;
    }

    // ===========================================
    // RENDERING
    // ===========================================
    
    function render() {
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      
      // Size canvas to full window
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      
      // Generate rectangles
      const rects = subdivide(0, 0, canvas.width, canvas.height);
      
      // Draw filled rectangles
      for (const r of rects) {
        ctx.fillStyle = pickColor();
        ctx.fillRect(r.x, r.y, r.w, r.h);
      }
      
      // Draw black outlines on top
      ctx.strokeStyle = CONFIG.lineColor;
      ctx.lineWidth = CONFIG.lineWidth;
      
      for (const r of rects) {
        ctx.strokeRect(r.x, r.y, r.w, r.h);
      }
      
      // Draw outer border
      ctx.strokeRect(0, 0, canvas.width, canvas.height);
    }

    // ===========================================
    // INITIALIZATION
    // ===========================================
    
    render();
    
    // Regenerate on click or resize
    window.addEventListener('click', render);
    window.addEventListener('resize', render);
  </script>
</body>
</html>
