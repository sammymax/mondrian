<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mondrian Generator</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      background: #000; 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      min-height: 100vh;
      overflow: hidden;
    }
    canvas { display: block; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <script>
    // ===========================================
    // TWEAKABLE PARAMETERS
    // ===========================================
    
    const CONFIG = {
      // Subdivision behavior
      minSplitArea: 120 * 120,   // Below this area: never split (0%)
      maxSplitArea: 500 * 500,   // Above this area: always split (100%)
      splitRatio: [0.1, 0.9],    // Range for where to place splits (0-1)
      minSplits: 2,              // Minimum number of pieces per split
      maxSplits: 4,              // Maximum number of pieces per split
      
      // Line styling
      lineWidth: 6,             // Thickness of black dividing lines
      lineColor: '#000000',
      
      // Colors and their relative weights
      colors: [
        { color: '#FFFFFF', weight: 10 },  // White (most common)
        { color: '#D40920', weight: 2 },   // Red
        { color: '#1356A2', weight: 2 },   // Blue
        { color: '#F7D842', weight: 2 },   // Yellow
      ],
      
      // Canvas padding from edge
      padding: 20,
    };

    // ===========================================
    // UTILITY FUNCTIONS
    // ===========================================
    
    // Random float between min and max
    function random(min, max) {
      return Math.random() * (max - min) + min;
    }
    
    // Pick a color based on weights
    function pickColor() {
      const totalWeight = CONFIG.colors.reduce((sum, c) => sum + c.weight, 0);
      let rand = Math.random() * totalWeight;
      
      for (const c of CONFIG.colors) {
        rand -= c.weight;
        if (rand <= 0) return c.color;
      }
      return CONFIG.colors[0].color;
    }

    // Inverse lerp: returns 0-1 based on where value falls in range
    function inverseLerp(value, min, max) {
      return Math.max(0, Math.min(1, (value - min) / (max - min)));
    }

    // ===========================================
    // SUBDIVISION ALGORITHM
    // ===========================================
    
    // Recursively subdivide a rectangle
    // Returns an array of final rectangles { x, y, w, h }
    function subdivide(x, y, w, h, depth = 0) {
      // Calculate split probability based on area
      const area = w * h;
      const splitProbability = inverseLerp(area, CONFIG.minSplitArea, CONFIG.maxSplitArea);
      const shouldSplit = Math.random() < splitProbability;
      
      if (!shouldSplit) {
        return [{ x, y, w, h }];
      }
      
      // Decide split direction (prefer splitting the longer dimension)
      const splitHorizontal = w > h ? true : h > w ? false : Math.random() < 0.5;
      
      // Determine how many pieces (2-4)
      const numPieces = Math.floor(random(CONFIG.minSplits, CONFIG.maxSplits + 1));
      
      // Generate split points
      const [minRatio, maxRatio] = CONFIG.splitRatio;
      const splitPoints = [];
      
      for (let i = 0; i < numPieces - 1; i++) {
        splitPoints.push(random(minRatio, maxRatio));
      }
      splitPoints.sort((a, b) => a - b);
      
      // Create child rectangles
      const results = [];
      let prev = 0;
      
      for (const ratio of splitPoints) {
        if (splitHorizontal) {
          const childW = (ratio - prev) * w;
          results.push(...subdivide(x + prev * w, y, childW, h, depth + 1));
        } else {
          const childH = (ratio - prev) * h;
          results.push(...subdivide(x, y + prev * h, w, childH, depth + 1));
        }
        prev = ratio;
      }
      
      // Final piece
      if (splitHorizontal) {
        results.push(...subdivide(x + prev * w, y, (1 - prev) * w, h, depth + 1));
      } else {
        results.push(...subdivide(x, y + prev * h, w, (1 - prev) * h, depth + 1));
      }
      
      return results;
    }

    // ===========================================
    // RENDERING
    // ===========================================
    
    function render() {
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      
      // Size canvas to full window
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      
      // Generate rectangles
      const rects = subdivide(0, 0, canvas.width, canvas.height);
      
      // Draw filled rectangles
      for (const r of rects) {
        ctx.fillStyle = pickColor();
        ctx.fillRect(r.x, r.y, r.w, r.h);
      }
      
      // Draw black outlines on top
      ctx.strokeStyle = CONFIG.lineColor;
      ctx.lineWidth = CONFIG.lineWidth;
      
      for (const r of rects) {
        ctx.strokeRect(r.x, r.y, r.w, r.h);
      }
      
      // Draw outer border
      ctx.strokeRect(0, 0, canvas.width, canvas.height);
    }

    // ===========================================
    // INITIALIZATION
    // ===========================================
    
    render();
    
    // Regenerate on click or resize
    window.addEventListener('click', render);
    window.addEventListener('resize', render);
  </script>
</body>
</html>
