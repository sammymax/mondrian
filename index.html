<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mondrian Generator</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      background: #000; 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      min-height: 100vh;
      overflow: hidden;
    }
    canvas { display: block; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <script>
    // ===========================================
    // TWEAKABLE PARAMETERS
    // ===========================================
    
    const CONFIG = {
      // Subdivision behavior
      minSplitSize: 120,         // Below this sqrt(area): never split (0%)
      maxSplitSize: 500,         // Above this sqrt(area): always split (100%)
      minSplitPixels: 40,        // Minimum pixels per piece when splitting
      minSplits: 2,              // Minimum number of pieces per split
      maxSplits: 4,              // Maximum number of pieces per split
      
      // Line styling
      lineWidth: 6,             // Thickness of black dividing lines
      lineColor: '#000000',
      
      // Colors and their relative weights
      colors: [
        { color: '#FFFFFF', weight: 6 },   // White (most common)
        { color: '#D40920', weight: 2 },   // Red
        { color: '#1356A2', weight: 2 },   // Blue
        { color: '#F7D842', weight: 2 },   // Yellow
      ],
      coloringAttempts: 100,    // Number of random colorings to try
      
      // Canvas padding from edge
      padding: 20,
    };

    // ===========================================
    // UTILITY FUNCTIONS
    // ===========================================
    
    // Random float between min and max
    function random(min, max) {
      return Math.random() * (max - min) + min;
    }
    
    // Inverse lerp: returns 0-1 based on where value falls in range
    function inverseLerp(value, min, max) {
      return Math.max(0, Math.min(1, (value - min) / (max - min)));
    }
    
    // Shuffle an array in place (Fisher-Yates)
    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }
    
    // Generate a random color assignment for n cells
    function randomColoring(n) {
      const totalWeight = CONFIG.colors.reduce((sum, c) => sum + c.weight, 0);
      const result = [];
      
      for (const c of CONFIG.colors) {
        const count = Math.round(n * c.weight / totalWeight);
        for (let i = 0; i < count; i++) {
          result.push(c.color);
        }
      }
      
      while (result.length < n) result.push(CONFIG.colors[0].color);
      while (result.length > n) result.pop();
      
      return shuffle(result);
    }
    
    // Score a coloring by how close area proportions match target weights
    function scoreColoring(coloring, rects) {
      const totalWeight = CONFIG.colors.reduce((sum, c) => sum + c.weight, 0);
      const totalArea = rects.reduce((sum, r) => sum + r.w * r.h, 0);
      
      let error = 0;
      for (const c of CONFIG.colors) {
        const targetProportion = c.weight / totalWeight;
        let actualArea = 0;
        for (let i = 0; i < rects.length; i++) {
          if (coloring[i] === c.color) {
            actualArea += rects[i].w * rects[i].h;
          }
        }
        const actualProportion = actualArea / totalArea;
        error += Math.pow(targetProportion - actualProportion, 2);
      }
      return error;
    }
    
    // Generate best coloring from N attempts
    function generateColors(rects) {
      let bestColoring = null;
      let bestScore = Infinity;
      
      for (let i = 0; i < CONFIG.coloringAttempts; i++) {
        const coloring = randomColoring(rects.length);
        const score = scoreColoring(coloring, rects);
        if (score < bestScore) {
          bestScore = score;
          bestColoring = coloring;
        }
      }
      return bestColoring;
    }

    // ===========================================
    // SUBDIVISION ALGORITHM
    // ===========================================
    
    // Recursively subdivide a rectangle
    // Returns an array of final rectangles { x, y, w, h }
    function subdivide(x, y, w, h, depth = 0) {
      
      // Calculate split probability based on cell size
      const size = Math.sqrt(w * h);
      const splitProbability = inverseLerp(size, CONFIG.minSplitSize, CONFIG.maxSplitSize);
      const shouldSplit = Math.random() < splitProbability;
      
      if (!shouldSplit) {
        return [{ x, y, w, h }];
      }
      
      // Decide split direction (prefer splitting the longer dimension)
      const splitHorizontal = w > h ? true : (h > w ? false : Math.random() < 0.5);
      
      // Determine how many pieces (2-4, capped by available space)
      const dimension = splitHorizontal ? w : h;
      const maxPieces = Math.floor(dimension / CONFIG.minSplitPixels);
      const numPieces = Math.min(
        maxPieces,
        Math.floor(random(CONFIG.minSplits, CONFIG.maxSplits + 1))
      );
      
      // Not enough room to split
      if (numPieces < 2) {
        return [{ x, y, w, h }];
      }
      
      // Generate piece sizes: each gets minSplitPixels + random share of remainder
      const reserved = numPieces * CONFIG.minSplitPixels;
      const extra = dimension - reserved;
      
      // Random weights for distributing extra space
      const weights = [];
      for (let i = 0; i < numPieces; i++) {
        weights.push(Math.random());
      }
      const totalWeight = weights.reduce((sum, wt) => sum + wt, 0);
      
      // Calculate piece sizes and convert to split points
      const splitPoints = [];
      let cumulative = 0;
      
      for (let i = 0; i < numPieces - 1; i++) {
        const pieceSize = CONFIG.minSplitPixels + (weights[i] / totalWeight) * extra;
        cumulative += pieceSize;
        splitPoints.push(cumulative / dimension);
      }
      
      // Create child rectangles
      const results = [];
      let prev = 0;
      
      for (const ratio of splitPoints) {
        if (splitHorizontal) {
          const childW = (ratio - prev) * w;
          results.push(...subdivide(x + prev * w, y, childW, h, depth + 1));
        } else {
          const childH = (ratio - prev) * h;
          results.push(...subdivide(x, y + prev * h, w, childH, depth + 1));
        }
        prev = ratio;
      }
      
      // Final piece
      if (splitHorizontal) {
        results.push(...subdivide(x + prev * w, y, (1 - prev) * w, h, depth + 1));
      } else {
        results.push(...subdivide(x, y + prev * h, w, (1 - prev) * h, depth + 1));
      }
      
      return results;
    }

    // ===========================================
    // RENDERING
    // ===========================================
    
    function render() {
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      
      // Size canvas to full window
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      
      // Generate rectangles and colors
      const rects = subdivide(0, 0, canvas.width, canvas.height);
      const colors = generateColors(rects);
      
      // Draw filled rectangles
      rects.forEach((r, i) => {
        ctx.fillStyle = colors[i];
        ctx.fillRect(r.x, r.y, r.w, r.h);
      });
      
      // Draw black outlines on top
      ctx.strokeStyle = CONFIG.lineColor;
      ctx.lineWidth = CONFIG.lineWidth;
      
      for (const r of rects) {
        ctx.strokeRect(r.x, r.y, r.w, r.h);
      }
      
      // Draw outer border
      ctx.strokeRect(0, 0, canvas.width, canvas.height);
    }

    // ===========================================
    // INITIALIZATION
    // ===========================================
    
    render();
    
    // Regenerate on click or resize
    window.addEventListener('click', render);
    window.addEventListener('resize', render);
  </script>
</body>
</html>
