<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      min-height: 100vh;
      background: #1a1a1a;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 16px;
      padding: 20px;
      font-family: system-ui, sans-serif;
    }
    h1 { color: white; font-weight: 300; letter-spacing: 0.1em; font-size: 1.2rem; }
    #canvas-container { border: 1px solid #333; box-shadow: 0 10px 40px rgba(0,0,0,0.5); }
    .controls { display: flex; gap: 12px; }
    button {
      padding: 10px 24px;
      font-size: 14px;
      font-weight: 500;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.2s;
    }
    .primary { background: white; color: #1a1a1a; }
    .primary:hover { background: #ddd; }
    .secondary { background: #444; color: white; }
    .secondary:hover { background: #555; }
    #seed { color: #666; font-size: 12px; }
  </style>
</head>
<body>
  <h1>Procedural Mondrian</h1>
  <div id="canvas-container"></div>
  <div class="controls">
    <button class="primary" onclick="regenerate()">Generate New</button>
    <button class="secondary" onclick="download()">Download PNG</button>
  </div>
  <div id="seed"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.11.0/p5.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/p5.brush@1.1.4/dist/p5.brush.min.js"></script>
  <script>
    let currentSeed = Date.now();
    
    function setup() {
      let canvas = createCanvas(600, 600, WEBGL);
      canvas.parent('canvas-container');
      brush.load();
      noLoop();
      generate();
    }
    
    function regenerate() {
      currentSeed = Date.now();
      generate();
    }
    
    function generate() {
      document.getElementById('seed').textContent = 'Seed: ' + currentSeed;
      brush.seed(currentSeed);
      randomSeed(currentSeed);
      
      // Reset transformations and offset for WEBGL coordinates
      resetMatrix();
      translate(-width/2, -height/2);
      
      // Background
      background('#f8f5ef');
      
      const colors = {
        red: ['#e31c25', '#ff1744', '#d50000'],
        yellow: ['#ffeb00', '#ffd600', '#ffea00'],
        blue: ['#0055ff', '#2979ff', '#0044cc'],
        black: ['#1a1a1a', '#212121'],
        lightBlue: ['#40c4ff', '#00b0ff', '#80d8ff'],
        white: ['#ffffff', '#fafafa', '#f5f5f5'],
      };
      
      const pick = arr => arr[Math.floor(random() * arr.length)];
      
      // ===== QUADTREE SUBDIVISION =====
      const blocks = [];
      const potentialLines = [];
      
      function subdivide(x, y, w, h) {
        const minSide = Math.min(w, h);
        
        // Probability of division based on side length
        let prob;
        if (minSide >= 200) {
          prob = 1;
        } else if (minSide <= 20) {
          prob = 0;
        } else {
          prob = (minSide - 20) / (200 - 20);
        }
        
        if (random() < prob) {
          // Divide into 4 quadrants
          const midX = x + w / 2;
          const midY = y + h / 2;
          
          // Store the division lines
          potentialLines.push({ x1: midX, y1: y, x2: midX, y2: y + h });
          potentialLines.push({ x1: x, y1: midY, x2: x + w, y2: midY });
          
          subdivide(x, y, w / 2, h / 2);
          subdivide(midX, y, w / 2, h / 2);
          subdivide(x, midY, w / 2, h / 2);
          subdivide(midX, midY, w / 2, h / 2);
        } else {
          // Terminal node - add as block (color assigned later)
          blocks.push({ x, y, w, h, col: null });
        }
      }
      
      // Start with full canvas
      subdivide(0, 0, width, height);
      
      // ===== SELECT LINES FROM QUADTREE =====
      const lines = [];
      for (const pl of potentialLines) {
        // ~40% chance to draw each line
        if (random() < 0.4) {
          // Randomly shorten the line for ad-hoc feel
          const shortenStart = random() < 0.3 ? random() * 0.3 : 0;
          const shortenEnd = random() < 0.3 ? random() * 0.3 : 0;
          
          const dx = pl.x2 - pl.x1;
          const dy = pl.y2 - pl.y1;
          
          lines.push({
            x1: pl.x1 + dx * shortenStart,
            y1: pl.y1 + dy * shortenStart,
            x2: pl.x2 - dx * shortenEnd,
            y2: pl.y2 - dy * shortenEnd,
            t: 0.4 + random() * 0.8  // thickness
          });
        }
      }
      
      // ===== ASSIGN COLORS =====
      // Create color pool with proportions (white most common)
      const colorProportions = {
        white: 10,
        red: 3,
        yellow: 3,
        blue: 3,
        black: 2,
        lightBlue: 2,
      };
      
      // Build color list based on proportions
      let colorPool = [];
      for (const [col, count] of Object.entries(colorProportions)) {
        for (let i = 0; i < count; i++) {
          colorPool.push(col);
        }
      }
      
      // Shuffle the color pool
      for (let i = colorPool.length - 1; i > 0; i--) {
        const j = Math.floor(random() * (i + 1));
        [colorPool[i], colorPool[j]] = [colorPool[j], colorPool[i]];
      }
      
      // Assign colors to blocks, cycling through pool if needed
      for (let i = 0; i < blocks.length; i++) {
        blocks[i].col = colorPool[i % colorPool.length];
      }
      
      // ===== DRAW BLOCKS =====
      // Watercolor params scaled by distance from center
      brush.noStroke();
      brush.noHatch();
      
      for (const b of blocks) {
        const baseColor = pick(colors[b.col]);
        
        // Calculate center of this rectangle
        const rectCenterX = b.x + b.w / 2;
        const rectCenterY = b.y + b.h / 2;
        
        // Calculate distance from canvas center (normalized 0-1)
        const canvasCenterX = width / 2;
        const canvasCenterY = height / 2;
        const maxDist = Math.sqrt(canvasCenterX * canvasCenterX + canvasCenterY * canvasCenterY);
        const dist = Math.sqrt(
          Math.pow(rectCenterX - canvasCenterX, 2) + 
          Math.pow(rectCenterY - canvasCenterY, 2)
        );
        
        // Painterliness: 1 at center, 0 at edges (squared for sharper falloff)
        const painterliness = Math.pow(1 - (dist / maxDist), 2);
        
        // Single watercolor layer with params scaled by painterliness
        brush.fill(baseColor, 150);
        brush.bleed(painterliness * 0.1, "out");
        brush.fillTexture(painterliness * 0.8, painterliness * 0.25);
        brush.rect(
          b.x + random(-1, 1) * painterliness,
          b.y + random(-1, 1) * painterliness,
          b.w + random(-2, 2) * painterliness,
          b.h + random(-2, 2) * painterliness
        );
      }
      
      // Force blend layers
      brush.reBlend();
      
      // ===== DRAW LINES =====
      // Add custom oil paint brush with bristle texture and pressure variation
      brush.add("oilpaint", {
        type: "custom",
        weight: 12,
        vibration: 0.2,
        opacity: 230,
        spacing: 0.3,
        blend: false,
        pressure: {
          type: "custom",
          min_max: [0.5, 1.15],
          // Creates natural thick-thin variation along stroke
          curve: (x) => 0.6 + 0.4 * Math.sin(x * Math.PI * 0.9)
        },
        tip: (_m) => {
          // Simulate flat brush with bristle texture (multiple thin rects with gaps)
          _m.rect(-5, -1.2, 2.2, 2.4);
          _m.rect(-2.2, -1.1, 1.8, 2.2);
          _m.rect(0.1, -1.3, 2, 2.6);
          _m.rect(2.6, -1.0, 2.2, 2.0);
        },
        rotate: "natural"
      });
      
      // Draw black lines with multiple passes for richness
      for (const l of lines) {
        // Main stroke
        brush.set('oilpaint', '#000000', l.t);
        brush.line(l.x1, l.y1, l.x2, l.y2);
        // Second pass slightly offset for paint buildup
        brush.set('oilpaint', '#0a0a0a', l.t * 0.7);
        brush.line(
          l.x1 + random(-0.3, 0.3), 
          l.y1 + random(-0.3, 0.3), 
          l.x2 + random(-0.3, 0.3), 
          l.y2 + random(-0.3, 0.3)
        );
      }
      
      brush.reDraw();
    }
    
    function download() {
      saveCanvas('mondrian-' + currentSeed, 'png');
    }
  </script>
</body>
</html>
