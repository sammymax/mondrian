<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      min-height: 100vh;
      background: #1a1a1a;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 16px;
      padding: 20px;
      font-family: system-ui, sans-serif;
    }
    h1 { color: white; font-weight: 300; letter-spacing: 0.1em; font-size: 1.2rem; text-align: center; }
    #canvas-container { border: 2px solid #555; box-shadow: 0 10px 40px rgba(0,0,0,0.5); line-height: 0; }
    #canvas-container canvas { display: block; }
    #header { width: 2400px; height: 30px; border: 2px white solid; box-sizing: content-box; }
    #progress { width: 0; height: 30px; position: absolute; background: #404040 }
    #title-wrapper { position: relative; height: 100%; display: flex; flex-direction: column; justify-content: center; }
    #controls { display: flex; gap: 12px; }
    button {
      padding: 10px 24px;
      font-size: 14px;
      font-weight: 500;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.2s;
      background: #444;
      color: white;
    }
    button:hover { background: #555; }
    button:disabled  { cursor: initial; background: #444; color: gray }
    #seed { color: #666; font-size: 12px; }
  </style>
</head>
<body>
  <div id="header">
    <div id="progress"></div>
    <div id="title-wrapper">
      <h1>Procedural Mondrian</h1>
    </div>
  </div>
  <div id="canvas-container"></div>
  <div id="controls">
    <button id="download" onclick="download()">Download PNG</button>
  </div>
  <div id="seed"></div>

  <script src="js/p5-1.11.11.min.js"></script>
  <script src="js/p5.brush.min.js"></script>
  <script>
    // Get seed from URL or generate one
    const urlParams = new URLSearchParams(window.location.search);
    const initialSeed = urlParams.get('seed') ? parseInt(urlParams.get('seed')) : Date.now();
    const complexity = urlParams.get('complexity') ? parseFloat(urlParams.get('complexity')) : 1.0;
    const tileLevel = urlParams.get('tile') ? parseInt(urlParams.get('tile')) : 0;
    const numTiles = (tileLevel === 0) ? 1 : 2 * tileLevel * tileLevel;
    let curTile = 0;
    debugLog(`Initial seed=${initialSeed}; complexity=${complexity}; tile=${tileLevel}`);

    function debugLog(msg) {
      console.log(`[${new Date().toISOString()}] ${msg}`);
    }

    function nextFrame() {
      return new Promise(resolve => requestAnimationFrame(resolve));
    }

    function setProgress(amt) {
      const p = curTile / numTiles + amt / numTiles;
      document.getElementById('progress').style.width = `${p * 2400}px`;
    }

    const FULL_WIDTH = 2400;
    const FULL_HEIGHT = 1200;
    const container = document.getElementById('canvas-container');

    // Render and add canvas to container. Returns the canvas element.
    async function createMondrian(seed, viewport = null) {
      const vp = viewport || { x: 0, y: 0, zoom: 1 };
      if (!viewport) {
        vp.w = FULL_WIDTH;
        vp.h = FULL_HEIGHT;
      } else {
        // Tiled: tile=N gives (2*N) x N tiles, each 1200/N x 1200/N logical pixels
        vp.w = Math.floor(FULL_WIDTH / vp.zoom);
        vp.h = Math.floor(FULL_WIDTH / vp.zoom);
      }

      // Calculate padded render region (clamped to full canvas bounds)
      const render = {
        x: Math.max(0, vp.x),
        y: Math.max(0, vp.y),
        w: Math.min(FULL_WIDTH, vp.x + vp.w) - Math.max(0, vp.x),
        h: Math.min(FULL_HEIGHT, vp.y + vp.h) - Math.max(0, vp.y)
      };
      // Crop offset: where in the rendered image does the actual viewport start
      const cropX = vp.x - render.x;
      const cropY = vp.y - render.y;

      return new Promise((resolve) => { new p5((p) => {

    let swirlShader;
    let canvas;

    const swirlVert = `
      attribute vec3 aPosition;
      attribute vec2 aTexCoord;
      varying vec2 vTexCoord;
      void main() {
        vTexCoord = aTexCoord;
        vec4 positionVec4 = vec4(aPosition, 1.0);
        positionVec4.xy = positionVec4.xy * 2.0 - 1.0;
        gl_Position = positionVec4;
      }
    `;
    
    const swirlFrag = `
      precision mediump float;
      varying vec2 vTexCoord;
      uniform sampler2D uTexture;
      uniform float uSwirlStrength;
      uniform float uNoiseStrength;
      uniform float uNoiseScale;

      // Permutation polynomial hash (attempt to mimic Perlin's permutation)
      vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
      vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
      vec4 permute(vec4 x) { return mod289(((x * 34.0) + 1.0) * x); }
      vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
      vec2 fade(vec2 t) { return t * t * t * (t * (t * 6.0 - 15.0) + 10.0); }

      // Classic Perlin 2D noise
      float cnoise(vec2 P) {
        vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);
        vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);
        Pi = mod289(Pi);
        vec4 ix = Pi.xzxz;
        vec4 iy = Pi.yyww;
        vec4 fx = Pf.xzxz;
        vec4 fy = Pf.yyww;
        vec4 i = permute(permute(ix) + iy);
        vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0;
        vec4 gy = abs(gx) - 0.5;
        vec4 tx = floor(gx + 0.5);
        gx = gx - tx;
        vec2 g00 = vec2(gx.x, gy.x);
        vec2 g10 = vec2(gx.y, gy.y);
        vec2 g01 = vec2(gx.z, gy.z);
        vec2 g11 = vec2(gx.w, gy.w);
        vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));
        g00 *= norm.x; g01 *= norm.y; g10 *= norm.z; g11 *= norm.w;
        float n00 = dot(g00, vec2(fx.x, fy.x));
        float n10 = dot(g10, vec2(fx.y, fy.y));
        float n01 = dot(g01, vec2(fx.z, fy.z));
        float n11 = dot(g11, vec2(fx.w, fy.w));
        vec2 fade_xy = fade(Pf.xy);
        vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);
        float n_xy = mix(n_x.x, n_x.y, fade_xy.y);
        return 2.3 * n_xy;
      }

      // Fractal Brownian Motion for more organic noise
      float fbm(vec2 p) {
        float value = 0.0;
        float amplitude = 0.5;
        for (int i = 0; i < 4; i++) {
          value += amplitude * cnoise(p);
          p *= 2.0;
          amplitude *= 0.5;
        }
        return value;
      }

      // Apply a swirl around a center point with given radius and strength
      vec2 swirl(vec2 uv, vec2 center, float radius, float strength) {
        vec2 offset = uv - center;
        float dist = length(offset);

        // Falloff: 1 at center, 0 at radius
        float factor = max(0.0, 1.0 - dist / radius);
        // Zero effect in outer 40%, then ramps up
        float thresh = 0.4;
        float swirlFactor = max(0.0, factor - thresh) / (1.0 - thresh);
        float angle = pow(swirlFactor, 2.5) * strength;

        float s = sin(angle);
        float c = cos(angle);
        vec2 rotated = vec2(
          offset.x * c - offset.y * s,
          offset.x * s + offset.y * c
        );
        return center + rotated;
      }

      // Calculate painterliness: 1 at center, 0 at edges
      float calcPainterliness(vec2 uv) {
        vec2 centered = uv - vec2(0.5);
        float edgeness = max(abs(centered.x) * 2.0, abs(centered.y) * 2.0);
        return max(0.0, 1.0 - edgeness);
      }

      void main() {
        vec2 uv = vTexCoord;

        // Multiple swirl centers with different radii and directions
        uv = swirl(uv, vec2(0.45, 0.45), 0.4, uSwirlStrength);
        uv = swirl(uv, vec2(0.45, 0.55), 0.4, -uSwirlStrength);
        uv = swirl(uv, vec2(0.55, 0.45), 0.4, uSwirlStrength);
        uv = swirl(uv, vec2(0.55, 0.55), 0.4, -uSwirlStrength);

        // Perlin noise displacement, scaled by painterliness (same formula as swirl)
        float painterliness = calcPainterliness(uv);
        float thresh = 0.05;
        float noiseFactor = max(0.0, painterliness - thresh) / (1.0 - thresh);
        float noiseScale = pow(noiseFactor, 2.0);

        vec2 noiseCoord = uv * uNoiseScale;
        vec2 noiseDisplacement = vec2(
          fbm(noiseCoord),
          fbm(noiseCoord + vec2(43.0, 17.0))  // offset for second axis
        );
        uv += noiseDisplacement * uNoiseStrength * noiseScale;

        gl_FragColor = texture2D(uTexture, uv);
      }
    `;
    
    p.setup = function() {
      debugLog('Setup started: viewport=' + JSON.stringify(vp) + ' render=' + JSON.stringify(render));
      p.pixelDensity(vp.zoom);
      canvas = p.createCanvas(render.w, render.h, p.WEBGL);
      canvas.parent(container);

      // Create shader
      swirlShader = p.createShader(swirlVert, swirlFrag);

      brush.instance(p);
      p.randomSeed(seed);  // Seed p5's random before load
      p.noiseSeed(seed);   // And noise
      brush.seed(seed);
      brush.load();
      p.noLoop();
      debugLog('Setup complete');
      generate(seed);
    };
    
    async function generate(seed) {
      debugLog(`Generation started with seed: ${seed}`);
      document.getElementById('seed').textContent = 'Seed: ' + seed;
      // Seed RNGs
      brush.seed(seed);
      p.randomSeed(seed);
      p.noiseSeed(seed);
      debugLog('RNGs seeded');

      // Reset transformations and offset for WEBGL coordinates
      // Translate so (0,0) is at top-left, offset by render region position
      p.resetMatrix();
      p.translate(-render.w/2 - render.x, -render.h/2 - render.y);

      // Background - fill the full area (will be clipped to viewport)
      p.background('#f8f5ef');
      debugLog('Background drawn');
      
      const colors = {
        red: ['#e31c25', '#ff1744', '#ff0033'],
        yellow: ['#ffeb00', '#ffd600', '#ffff00'],
        blue: ['#0055ff', '#2979ff', '#0066ff'],
        black: ['#1a1a1a', '#212121'],
        lightBlue: ['#40c4ff', '#00b0ff', '#00e5ff'],
        white: ['#ffffff', '#fafafa', '#f5f5f5'],
        green: ['#00c853', '#00e676', '#00ff55'],
        orange: ['#ff6d00', '#ff9100', '#ff5500'],
      };
      
      const pick = arr => arr[Math.floor(p.random() * arr.length)];
      
      // ===== QUADTREE SUBDIVISION =====
      const blocks = [];
      const potentialLines = [];
      
      function subdivide(x, y, w, h) {
        const minSide = Math.min(w, h);
        
        // Probability of division based on side length
        let prob;
        if (minSide >= 200) {
          prob = 1;
        } else if (minSide <= 20) {
          prob = 0;
        } else {
          prob = (minSide - 20) / (200 - 20);
        }
        
        if (complexity * p.random() < prob) {
          // Divide into 4 quadrants
          const midX = x + w / 2;
          const midY = y + h / 2;
          
          // Store the division lines
          potentialLines.push({ x1: midX, y1: y, x2: midX, y2: y + h });
          potentialLines.push({ x1: x, y1: midY, x2: x + w, y2: midY });
          
          subdivide(x, y, w / 2, h / 2);
          subdivide(midX, y, w / 2, h / 2);
          subdivide(x, midY, w / 2, h / 2);
          subdivide(midX, midY, w / 2, h / 2);
        } else {
          // Terminal node - add as block (color assigned later)
          blocks.push({ x, y, w, h, col: null });
        }
      }
      
      // Start with two squares side by side (use FULL dimensions for consistent layout)
      subdivide(0, 0, FULL_HEIGHT, FULL_HEIGHT);
      subdivide(FULL_HEIGHT, 0, FULL_HEIGHT, FULL_HEIGHT);
      debugLog(`Quadtree subdivision complete: ${blocks.length} blocks, ${potentialLines.length} potential lines`);
      
      // ===== HELPER: CALCULATE EDGENESS =====
      // Returns 0 at center, 1 at edges (using ray projection)
      // Use FULL dimensions for consistent layout across tiles
      const canvasCenterX = FULL_WIDTH / 2;
      const canvasCenterY = FULL_HEIGHT / 2;
      
      function calcEdgeness(x, y) {
        const dx = x - canvasCenterX;
        const dy = y - canvasCenterY;
        return Math.max(Math.abs(dx) / canvasCenterX, Math.abs(dy) / canvasCenterY);
      }
      
      // ===== SELECT LINES FROM QUADTREE =====
      const lines = [];
      
      for (const pl of potentialLines) {
        // Calculate center of this line
        const lineCenterX = (pl.x1 + pl.x2) / 2;
        const lineCenterY = (pl.y1 + pl.y2) / 2;
        
        // Edgeness: 0 at center, 1 at edges
        const edgeness = calcEdgeness(lineCenterX, lineCenterY);
        
        // Probability: higher at edges (5% at center, 95% at edges, quadratic)
        const prob = 0.05 + edgeness * edgeness * 0.9;

        if (p.random() < prob) {
          // Line painterliness (inverse of edgeness): 0 at edges, 1 at center
          const linePainterliness = 1 - edgeness;

          // Randomly shorten the line - more shortening toward center
          const shortenProb = linePainterliness * 0.5;  // 0% at edges, 50% at center
          const shortenAmt = linePainterliness * 0.4;   // 0% at edges, up to 40% at center
          const shortenStart = p.random() < shortenProb ? p.random() * shortenAmt : 0;
          const shortenEnd = p.random() < shortenProb ? p.random() * shortenAmt : 0;
          
          const dx = pl.x2 - pl.x1;
          const dy = pl.y2 - pl.y1;
          
          lines.push({
            x1: pl.x1 + dx * shortenStart,
            y1: pl.y1 + dy * shortenStart,
            x2: pl.x2 - dx * shortenEnd,
            y2: pl.y2 - dy * shortenEnd,
            t: 0.6 + p.random() * 0.4 + linePainterliness * p.random() * 0.4  // more thickness variation toward center
          });
        }
      }
      debugLog(`Lines selected: ${lines.length} lines`);

      // ===== CAPTURE STATE FOR EXPORT =====
      // We need to pre-compute all random decisions for blocks so Python can replicate exactly
      const exportBlocks = [];

      // Color proportions at painterliness 0 and 1
      const colorPropsAt0 = {
        white: 10, red: 3, yellow: 3, blue: 3, black: 2, lightBlue: 2, green: 0, orange: 0
      };
      const colorPropsAt1 = {
        white: 0, red: 3, yellow: 3, blue: 3, black: 0, lightBlue: 2, green: 3, orange: 3
      };
      
      // Function to sample color based on painterliness
      function sampleColor(painterliness) {
        // Interpolate proportions
        const props = {};
        for (const col of Object.keys(colorPropsAt0)) {
          props[col] = colorPropsAt0[col] * (1 - painterliness) + colorPropsAt1[col] * painterliness;
        }
        
        // Calculate total weight
        let total = 0;
        for (const col of Object.keys(props)) {
          total += props[col];
        }
        
        // Sample
        let r = p.random() * total;
        for (const col of Object.keys(props)) {
          r -= props[col];
          if (r <= 0) return col;
        }
        return 'white'; // fallback
      }
      
      debugLog('Color sampling function ready');
      
      // ===== DRAW BLOCKS =====
      // Watercolor params scaled by distance from center
      brush.seed(seed);  // Re-seed before drawing to ensure consistent state
      brush.noStroke();
      brush.noHatch();
      debugLog(`Starting to draw ${blocks.length} blocks...`);

      async function renderBlock(i) {
        const b = blocks[i];
        // Calculate center of this rectangle
        const rectCenterX = b.x + b.w / 2;
        const rectCenterY = b.y + b.h / 2;

        // Painterliness: 1 at center, 0 at edges
        const painterliness = Math.max(0, 1 - calcEdgeness(rectCenterX, rectCenterY));

        // Sample color based on painterliness (sqrt to shift distribution)
        const colorKey = sampleColor(Math.sqrt(painterliness));

        // Skip white blocks
        if (colorKey === 'white') return;

        const baseColor = pick(colors[colorKey]);

        // Check if block touches outer border (use FULL dimensions)
        const touchesBorder = b.x <= 0 || b.y <= 0 || b.x + b.w >= FULL_WIDTH || b.y + b.h >= FULL_HEIGHT;

        // Pre-compute jitter values for export
        const jitterX = p.random(-1, 1) * painterliness;
        const jitterY = p.random(-1, 1) * painterliness;
        const jitterW = p.random(-2, 2) * painterliness;
        const jitterH = p.random(-2, 2) * painterliness;

        // Capture for export
        exportBlocks.push({
          x: b.x, y: b.y, w: b.w, h: b.h,
          colorKey: colorKey,
          color: baseColor,
          painterliness: painterliness,
          touchesBorder: touchesBorder,
          jitterX: jitterX, jitterY: jitterY,
          jitterW: jitterW, jitterH: jitterH
        });

        if (touchesBorder) {
          // Standard solid fill for border blocks
          p.push();
          p.noStroke();
          p.fill(baseColor);
          p.rect(b.x, b.y, b.w, b.h);
          p.pop();
        } else {
          // Single watercolor layer with params scaled by painterliness
          brush.fill(baseColor, 150);
          brush.bleed(Math.pow(painterliness, 1) * 0.5, "out");
          brush.fillTexture(painterliness * 0.8, painterliness * 0.25);
          brush.rect(
            b.x + jitterX,
            b.y + jitterY,
            b.w + jitterW,
            b.h + jitterH
          );
        }
        setProgress(0.90 * (i + 1) / blocks.length);
        await nextFrame();
      }
      for (let i = 0; i < blocks.length; i++) await renderBlock(i);

      // Force blend layers
      debugLog('Blocks drawn, starting reBlend...');
      brush.reBlend();
      debugLog('reBlend complete');
      
      // ===== DRAW LINES =====
      // Add custom oil paint brush with bristle texture and pressure variation
      brush.seed(seed);  // Re-seed before lines
      debugLog('Setting up line brush...');
      brush.add("oilpaint", {
        type: "custom",
        weight: 12,
        vibration: 0.2,
        opacity: 230,
        spacing: 0.3,
        blend: false,
        pressure: {
          type: "custom",
          min_max: [0.5, 1.15],
          // Creates natural thick-thin variation along stroke
          curve: (x) => 0.6 + 0.4 * Math.sin(x * Math.PI * 0.9)
        },
        tip: (_m) => {
          // Simulate flat brush with bristle texture (multiple thin rects with gaps)
          _m.rect(-5, -1.2, 2.2, 2.4);
          _m.rect(-2.2, -1.1, 1.8, 2.2);
          _m.rect(0.1, -1.3, 2, 2.6);
          _m.rect(2.6, -1.0, 2.2, 2.0);
        },
        rotate: "natural"
      });
      debugLog('Line brush created, drawing lines...');
      
      // Draw black lines with multiple passes for richness
      async function renderLine(i) {
        const l = lines[i];
        // Main stroke
        brush.set('oilpaint', '#000000', l.t);
        brush.line(l.x1, l.y1, l.x2, l.y2);
        // Second pass slightly offset for paint buildup
        brush.set('oilpaint', '#0a0a0a', l.t * 0.7);
        brush.line(
          l.x1 + p.random(-0.3, 0.3),
          l.y1 + p.random(-0.3, 0.3),
          l.x2 + p.random(-0.3, 0.3),
          l.y2 + p.random(-0.3, 0.3)
        );
        setProgress(0.90 + 0.10 * (i + 1) / lines.length);
        await nextFrame();
      }
      for (let i = 0; i < lines.length; i++) await renderLine(i);
      setProgress(1);
      
      debugLog('Lines drawn, starting reDraw...');
      brush.reDraw();
      debugLog('reDraw complete');

      // ===== EXPORT STATE AS JSON =====
      // Only export for the main (non-tiled) render
      if (!viewport) {
        const exportState = {
          seed: seed,
          width: FULL_WIDTH,
          height: FULL_HEIGHT,
          blocks: exportBlocks,
          lines: lines
        };
        console.log('=== MONDRIAN_STATE_JSON_START ===');
        console.log(JSON.stringify(exportState, null, 2));
        console.log('=== MONDRIAN_STATE_JSON_END ===');
        debugLog(`Exported state: ${exportBlocks.length} blocks, ${lines.length} lines`);
      }

      // ===== APPLY SWIRL SHADER (currently disabled) =====
      // When shader is re-enabled, this section applies post-processing
      /*
      debugLog('Applying swirl shader...');
      let pg = p.createGraphics(vp.w, vp.h, p.WEBGL);
      pg.image(p.get(), -vp.w/2, -vp.h/2);
      p.shader(swirlShader);
      swirlShader.setUniform('uTexture', pg);
      swirlShader.setUniform('uSwirlStrength', 1.2);
      swirlShader.setUniform('uNoiseStrength', 0.125);
      swirlShader.setUniform('uNoiseScale', 8.0);
      p.noStroke();
      p.rect(-vp.w/2, -vp.h/2, vp.w, vp.h);
      p.resetShader();
      pg.remove();
      debugLog('Swirl shader applied');
      */
      resolve(canvas.elt);
    }

    }); }); // end p5 instance, end Promise
    } // end createMondrian

    // Lightweight initialization of p5.brush without rendering
    function initBrush() {
      return new Promise((resolve) => {
        new p5((p) => {
          p.setup = function() {
            debugLog('Initializing p5.brush...');
            p.pixelDensity(1);
            let canvas = p.createCanvas(FULL_WIDTH, FULL_HEIGHT, p.WEBGL);
            brush.instance(p);
            brush.load();
            p.noLoop();
            debugLog('p5.brush initialized');
            // Remove the init canvas immediately
            canvas.remove();
            p.remove();
            resolve();
          };
        });
      });
    }

    async function renderAll() {
      document.getElementById('download').setAttribute("disabled", true);
      if (tileLevel === 0) {
        // No tiling - single canvas
        await createMondrian(initialSeed, null);
      } else {
        // Tiled rendering: tile=N gives (2*N) x N tiles at Nx resolution
        const zoom = 2 * tileLevel;
        const cols = zoom;
        const rows = tileLevel;
        const tileW = FULL_WIDTH / cols;
        const tileH = FULL_HEIGHT / rows;

        debugLog(`Tiled render: zoom=${zoom}, cols=${cols}, rows=${rows}, tileSize=${tileW}x${tileH}`);

        // Initialize p5.brush with full canvas dimensions
        await initBrush();

        // Setup CSS grid on container for tile layout
        container.style.display = 'grid';
        container.style.gridTemplateColumns = `repeat(${cols}, ${tileW}px)`;
        container.style.lineHeight = '0';

        curTile = 0;
        // Render each tile - canvases are added to container in grid order
        for (let row = 0; row < rows; row++) {
          for (let col = 0; col < cols; col++, curTile++) {
            const vp = { x: col * tileW, y: row * tileH, zoom: zoom };
            const resWebGL = await createMondrian(initialSeed, vp);

            // Browsers have a limit of ~16 WebGL contexts, so replace with 2D.
            const res2D = document.createElement('canvas');
            res2D.width = FULL_WIDTH;
            res2D.height = FULL_WIDTH;
            const ctx = res2D.getContext('2d');
            ctx.drawImage(resWebGL, 0, 0);
            container.replaceChild(res2D, resWebGL);
            res2D.style.width = `${FULL_WIDTH / zoom}px`;
            res2D.style.height = `${FULL_WIDTH / zoom}px`;

            debugLog(`Tile ${row},${col} complete`);
          }
        }
      }
      document.getElementById('download').removeAttribute("disabled");
    }
    renderAll();

    function download() {
      const suffix = tileLevel > 0 ? `-tile${tileLevel}` : '';
      const canvases = container.querySelectorAll('canvas');

      if (canvases.length === 1) {
        // Single canvas - download directly
        canvases[0].toBlob(blob => {
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `mondrian-${initialSeed}-${complexity}${suffix}.png`;
          a.click();
          URL.revokeObjectURL(url);
        }, 'image/png');
      } else {
        // Multiple canvases - composite them
        const zoom = 2 * tileLevel;
        const cols = zoom;
        const tileW = FULL_WIDTH / cols;
        const tileH = FULL_HEIGHT / tileLevel;

        const result = document.createElement('canvas');
        result.width = FULL_WIDTH * zoom;
        result.height = FULL_HEIGHT * zoom;
        const ctx = result.getContext('2d');

        canvases.forEach((c, i) => {
          const col = i % cols;
          const row = Math.floor(i / cols);
          ctx.drawImage(c, col * tileW * zoom, row * tileH * zoom);
        });

        result.toBlob(blob => {
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `mondrian-${initialSeed}-${complexity}${suffix}.png`;
          a.click();
          URL.revokeObjectURL(url);
        }, 'image/png');
      }
    }
  </script>
</body>
</html>
